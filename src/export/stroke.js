function getStroke(data) {    if (!data) return null;    var stroke = {};    stroke.join = data.property('ADBE Vector Stroke Line Join').value;    if (stroke.join === 1) {        stroke.miterLimit = getProperty(data.property('ADBE Vector Stroke Miter Limit'));    }    stroke.join = setStrokeTypeAsString(stroke.join);    stroke.cap = data.property('ADBE Vector Stroke Line Cap').value;    stroke.cap = setCapTypeAsString(stroke.cap);    stroke.color = getProperty(data.property('ADBE Vector Stroke Color'));    stroke.color = normalizeColor(stroke.color);    stroke.opacity = getProperty(data.property('ADBE Vector Stroke Opacity'));    stroke.opacity = normalizeOpacity(stroke.opacity);    stroke.width = getProperty(data.property('ADBE Vector Stroke Width'));    return stroke;}function setStrokeTypeAsString(number) {    switch (number) {        case 2:            return 'round';            break;        case 3:            return 'bevel';            break;        default:            return 'miter';    }}function setCapTypeAsString(number) {    switch (number) {        case 2:            return 'round';            break;        case 3:            return 'square'; //  AE-> projecting === Canvas -> Square            break;        default:            return 'butt';    }}function normalizeOpacity(frames) {    for (var i = 0; i < frames.length; i++) {        frames[i].v = frames[i].v / 100;    }    return frames;}function normalizeColor(frames) {    for (var i = 0; i < frames.length; i++) {        var color = frames[i].v;        frames[i].v = [            Math.round(color[0] * 255),            Math.round(color[1] * 255),            Math.round(color[2] * 255)        ]    }    return frames;}